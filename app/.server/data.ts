import { computeDestinationPoint } from "geolib";
import {InterpolatedWeather, WeatherLocation} from "~/.server/interfaces";

//Generated by Claude using the geolib library to sample points eastward or westward and format them in the string we need for the open meteo api call
export function generateCoordinateString(
  lat: number,
  lon: number,
  eventType: "sunrise" | "sunset"
): string {
  // Input validation
  if (lat < -90 || lat > 90) throw new Error("Invalid latitude");
  if (lon < -180 || lon > 180) throw new Error("Invalid longitude");

  const bearing = eventType === "sunrise" ? 90 : 270;

  // Separate arrays for latitudes and longitudes
  const latitudes: number[] = [];
  const longitudes: number[] = [];

  // Generate 6 points (including starting point)
  for (let i = 0; i < 6; i++) {
    const distance = i * 20 * 1609.34; // Convert miles to meters

    const point = computeDestinationPoint(
      { latitude: lat, longitude: lon },
      distance,
      bearing
    );

    latitudes.push(Number(point.latitude.toFixed(6)));
    longitudes.push(Number(point.longitude.toFixed(6)));
  }

  return `latitude=${latitudes.join(",")}&longitude=${longitudes.join(",")}`;
}



function findBoundingTimeIndices(times: number[], targetTime: number): [number, number] {
// Binary search for more efficient lookup
  let left = 0;
  let right = times.length - 1;
// Handle out of bounds cases
  if (targetTime <= times[left]) return [0, 0];
  if (targetTime >= times[right]) return [right, right];
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (times[mid] <= targetTime && times[mid + 1] > targetTime) {
      return [mid, mid + 1];
    }

    if (times[mid] > targetTime) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
// Fallback (should never reach here with valid data)
  throw new Error('Unable to find bounding times');
}
function calculateInterpolationWeight(
  time1: number,
  time2: number,
  targetTime: number
): number {
  const weight = (targetTime - time1) / (time2 - time1);
// Ensure weight is bounded between 0 and 1
  return Math.max(0, Math.min(1, weight));
}
function lerp(a: number, b: number, weight: number): number {
  if (isNaN(a) || isNaN(b)) {
    throw new Error('Invalid number in interpolation');
  }
  return a + (b - a) * weight;
}
export function interpolateWeatherData(
  apiResponse: WeatherLocation[],
  targetTime: number
): InterpolatedWeather[] {
  if (!Array.isArray(apiResponse) || !apiResponse.length) {
    throw new Error('Invalid API response');
  }
  return apiResponse.map(location => {
    if (!location.hourly?.time?.length) {
      throw new Error('Invalid location data structure');
    }
    const { time } = location.hourly;

// Find bounding indices using binary search
    const [lowerIndex, upperIndex] = findBoundingTimeIndices(time, targetTime);

// Calculate interpolation weight
    const weight = calculateInterpolationWeight(
      time[lowerIndex],
      time[upperIndex],
      targetTime
    );

    try {
      return {
        latitude: location.latitude,
        longitude: location.longitude,
        temperature_2m: lerp(
          location.hourly.temperature_2m[lowerIndex],
          location.hourly.temperature_2m[upperIndex],
          weight
        ),
        cloud_cover: lerp(
          location.hourly.cloud_cover[lowerIndex],
          location.hourly.cloud_cover[upperIndex],
          weight
        ),
        cloud_cover_low: lerp(
          location.hourly.cloud_cover_low[lowerIndex],
          location.hourly.cloud_cover_low[upperIndex],
          weight
        ),
        cloud_cover_mid: lerp(
          location.hourly.cloud_cover_mid[lowerIndex],
          location.hourly.cloud_cover_mid[upperIndex],
          weight
        ),
        cloud_cover_high: lerp(
          location.hourly.cloud_cover_high[lowerIndex],
          location.hourly.cloud_cover_high[upperIndex],
          weight
        ),
        visibility: lerp(
          location.hourly.visibility[lowerIndex],
          location.hourly.visibility[upperIndex],
          weight
        ),
      };
    } catch (error) {
      // @ts-ignore
      throw new Error(`Error interpolating values: ${error.message}`);
    }
  });
}