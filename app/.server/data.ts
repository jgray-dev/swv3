import { computeDestinationPoint } from "geolib";
import {
  AveragedValues,
  InterpolatedWeather,
  WeatherLocation,
} from "~/.server/interfaces";

//Generated by Claude using the geolib library to sample points eastward or westward and format them in the string we need for the open meteo api call
export function generateCoordinateString(
  lat: number,
  lon: number,
  eventType: "sunrise" | "sunset"
): string {
  // Input validation
  if (lat < -90 || lat > 90) throw new Error("Invalid latitude");
  if (lon < -180 || lon > 180) throw new Error("Invalid longitude");

  const bearing = eventType === "sunrise" ? 90 : 270;

  // Separate arrays for latitudes and longitudes
  const latitudes: number[] = [];
  const longitudes: number[] = [];

  // Generate 6 points (including starting point)
  for (let i = 0; i < 6; i++) {
    const distance = i * 20 * 1609.34; // Convert miles to meters

    const point = computeDestinationPoint(
      { latitude: lat, longitude: lon },
      distance,
      bearing
    );

    latitudes.push(Number(point.latitude.toFixed(6)));
    longitudes.push(Number(point.longitude.toFixed(6)));
  }

  return `latitude=${latitudes.join(",")}&longitude=${longitudes.join(",")}`;
}

function findBoundingTimeIndices(
  times: number[],
  targetTime: number
): [number, number] {
  // Binary search for more efficient lookup
  let left = 0;
  let right = times.length - 1;
  // Handle out of bounds cases
  if (targetTime <= times[left]) return [0, 0];
  if (targetTime >= times[right]) return [right, right];
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (times[mid] <= targetTime && times[mid + 1] > targetTime) {
      return [mid, mid + 1];
    }

    if (times[mid] > targetTime) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  // Fallback (should never reach here with valid data)
  throw new Error("Unable to find bounding times");
}
function calculateInterpolationWeight(
  time1: number,
  time2: number,
  targetTime: number
): number {
  const weight = (targetTime - time1) / (time2 - time1);
  // Ensure weight is bounded between 0 and 1
  return Math.max(0, Math.min(1, weight));
}
function lerp(a: number, b: number, weight: number): number {
  if (isNaN(a) || isNaN(b)) {
    throw new Error("Invalid number in interpolation");
  }
  return a + (b - a) * weight;
}
export function interpolateWeatherData(
  apiResponse: WeatherLocation[],
  targetTime: number
): InterpolatedWeather[] {
  if (!Array.isArray(apiResponse) || !apiResponse.length) {
    throw new Error("Invalid API response");
  }
  return apiResponse.map((location) => {
    if (!location.hourly?.time?.length) {
      throw new Error("Invalid location data structure");
    }
    const { time } = location.hourly;

    // Find bounding indices using binary search
    const [lowerIndex, upperIndex] = findBoundingTimeIndices(time, targetTime);

    // Calculate interpolation weight
    const weight = calculateInterpolationWeight(
      time[lowerIndex],
      time[upperIndex],
      targetTime
    );

    try {
      return {
        latitude: location.latitude,
        longitude: location.longitude,
        temperature_2m: lerp(
          location.hourly.temperature_2m[lowerIndex],
          location.hourly.temperature_2m[upperIndex],
          weight
        ),
        cloud_cover: lerp(
          location.hourly.cloud_cover[lowerIndex],
          location.hourly.cloud_cover[upperIndex],
          weight
        ),
        cloud_cover_low: lerp(
          location.hourly.cloud_cover_low[lowerIndex],
          location.hourly.cloud_cover_low[upperIndex],
          weight
        ),
        cloud_cover_mid: lerp(
          location.hourly.cloud_cover_mid[lowerIndex],
          location.hourly.cloud_cover_mid[upperIndex],
          weight
        ),
        cloud_cover_high: lerp(
          location.hourly.cloud_cover_high[lowerIndex],
          location.hourly.cloud_cover_high[upperIndex],
          weight
        ),
        visibility: lerp(
          location.hourly.visibility[lowerIndex],
          location.hourly.visibility[upperIndex],
          weight
        ),
      };
    } catch (error) {
      // @ts-ignore
      throw new Error(`Error interpolating values: ${error.message}`);
    }
  });
}

export function averageData(data: InterpolatedWeather[]): AveragedValues {
  if (!data.length) {
    throw new Error("Data array cannot be empty");
  }

  const totalEntries = data.length;
  const cloudSums = data.reduce((acc, curr) => ({
    cloud_cover: acc.cloud_cover + curr.cloud_cover,
    high_clouds: acc.high_clouds + curr.cloud_cover_high,
    mid_clouds: acc.mid_clouds + curr.cloud_cover_mid,
    low_clouds: acc.low_clouds + curr.cloud_cover_low
  }), {
    cloud_cover: 0,
    high_clouds: 0,
    mid_clouds: 0,
    low_clouds: 0
  });

  return {
    cloud_cover: cloudSums.cloud_cover / totalEntries,
    high_clouds: cloudSums.high_clouds / totalEntries,
    mid_clouds: cloudSums.mid_clouds / totalEntries,
    low_clouds: cloudSums.low_clouds / totalEntries,
    visibility: data[0].visibility,
    temperature: data[0].temperature_2m
  };
}


export function getStringLiteral(currentTime: number, eventTime: number, type: string): string {
  const differenceInSeconds = eventTime - currentTime;
  const absoluteDifferenceInHours = Math.abs(differenceInSeconds) / 3600;
  const absoluteDifferenceInMinutes = Math.abs(differenceInSeconds) / 60;

  // If the difference is less than 1 minute
  if (absoluteDifferenceInMinutes < 1) {
    return `${type=="sunset"?"sunsetting":"sunrising"} just now`;
  }

  // If the difference is less than 1 hour
  if (absoluteDifferenceInHours < 1) {
    const minutes = Math.round(absoluteDifferenceInMinutes);
    return differenceInSeconds < 0
      ? `${type} ${minutes} minute${minutes === 1 ? '' : 's'} ago`
      : `${type} in ${minutes} minute${minutes === 1 ? '' : 's'}`;
  }

  // For hour(s) difference
  const hours = Math.round(absoluteDifferenceInHours);
  return differenceInSeconds < 0
    ? `${type} ${hours} hour${hours === 1 ? '' : 's'} ago`
    : `${type} in ${hours} hour${hours === 1 ? '' : 's'}`;
}

export function getRelative(now: number, time: number): string {
  if (Math.abs(now - time) <= 500) return "current"
  return now > time? "past" : "future"
}